package manglet

import (
	"testing"
)

var in = "https://github.com/tpkn/manglet/1.0.0"

func TestByStepsLetters(t *testing.T) {
	if Scenarios(in, []string{"l"}) != "xxxxx://xxxxxx.xxx/xxxx/xxxxxxx/1.0.0" {
		t.Error("Something wrong with letters replacement function")
	}
}

func TestBySteps_Digits(t *testing.T) {
	if Scenarios(in, []string{"d"}) != "https://github.com/tpkn/manglet/0.0.0" {
		t.Error("Something wrong with digits replacement function")
	}
}

func TestByStepsSymbols(t *testing.T) {
	if Scenarios(in, []string{"s"}) != "https---github-com-tpkn-manglet-1-0-0" {
		t.Error("Something wrong with symbols replacement function")
	}
}

func TestBySteps_All(t *testing.T) {
	if Scenarios(in, []string{"l", "d", "s"}) != "xxxxx---xxxxxx-xxx-xxxx-xxxxxxx-0-0-0" {
		t.Error("The result looks wrong")
	}
}

func BenchmarkBySteps_Letters(b *testing.B) {
	for i := 0; i < b.N; i++ {
		Scenarios(in, []string{"l"})
	}
}

func BenchmarkBySteps_LettersDigits(b *testing.B) {
	for i := 0; i < b.N; i++ {
		Scenarios(in, []string{"l", "d"})
	}
}

func BenchmarkBySteps_All(b *testing.B) {
	for i := 0; i < b.N; i++ {
		Scenarios(in, []string{"l", "d", "s"})
	}
}


// ----------------------------------------
var text = "In this article we discover how to implement a challenges solution in Go and then increase performance by 650% going below 4 seconds from 25 seconds, which is over 20x improvement from the challenges original version of 84 seconds over the course of 9 revisions. We’ll also have a look at performance limiting aspects of this challenge.\nPerformance is our priority for now. Marks and others pointed out that code quality can be equally important. Thats very true and Niedringhaus’s first implementation was “just” about how to solve the challenge and not about performance; that became a focus when other solutions where available to her. For a program to run such a long time, nearly one an a half minute, it is a valid thing to measure its performance and then compare it to the code that lead to this perfomance. With that measurement we can at least quantify a quality of the code.\nBut lets first get an overview about the challenge, have a short look at two existing implementations and then create a first port of the fastest of those implementations to Go.\nIn this article we discover how to implement a challenges solution in Go and then increase performance by 650% going below 4 seconds from 25 seconds, which is over 20x improvement from the challenges original version of 84 seconds over the course of 9 revisions. We’ll also have a look at performance limiting aspects of this challenge.\nPerformance is our priority for now. Marks and others pointed out that code quality can be equally important. Thats very true and Niedringhaus’s first implementation was “just” about how to solve the challenge and not about performance; that became a focus when other solutions where available to her. For a program to run such a long time, nearly one an a half minute, it is a valid thing to measure its performance and then compare it to the code that lead to this perfomance. With that measurement we can at least quantify a quality of the code.\nBut lets first get an overview about the challenge, have a short look at two existing implementations and then create a first port of the fastest of those implementations to Go.\nIn this article we discover how to implement a challenges solution in Go and then increase performance by 650% going below 4 seconds from 25 seconds, which is over 20x improvement from the challenges original version of 84 seconds over the course of 9 revisions. We’ll also have a look at performance limiting aspects of this challenge.\nPerformance is our priority for now. Marks and others pointed out that code quality can be equally important. Thats very true and Niedringhaus’s first implementation was “just” about how to solve the challenge and not about performance; that became a focus when other solutions where available to her. For a program to run such a long time, nearly one an a half minute, it is a valid thing to measure its performance and then compare it to the code that lead to this perfomance. With that measurement we can at least quantify a quality of the code.\nBut lets first get an overview about the challenge, have a short look at two existing implementations and then create a first port of the fastest of those implementations to Go.\nIn this article we discover how to implement a challenges solution in Go and then increase performance by 650% going below 4 seconds from 25 seconds, which is over 20x improvement from the challenges original version of 84 seconds over the course of 9 revisions. We’ll also have a look at performance limiting aspects of this challenge.\nPerformance is our priority for now. Marks and others pointed out that code quality can be equally important. Thats very true and Niedringhaus’s first implementation was “just” about how to solve the challenge and not about performance; that became a focus when other solutions where available to her. For a program to run such a long time, nearly one an a half minute, it is a valid thing to measure its performance and then compare it to the code that lead to this perfomance. With that measurement we can at least quantify a quality of the code.\nBut lets first get an overview about the challenge, have a short look at two existing implementations and then create a first port of the fastest of those implementations to Go.\nIn this article we discover how to implement a challenges solution in Go and then increase performance by 650% going below 4 seconds from 25 seconds, which is over 20x improvement from the challenges original version of 84 seconds over the course of 9 revisions. We’ll also have a look at performance limiting aspects of this challenge.\nPerformance is our priority for now. Marks and others pointed out that code quality can be equally important. Thats very true and Niedringhaus’s first implementation was “just” about how to solve the challenge and not about performance; that became a focus when other solutions where available to her. For a program to run such a long time, nearly one an a half minute, it is a valid thing to measure its performance and then compare it to the code that lead to this perfomance. With that measurement we can at least quantify a quality of the code.\nBut lets first get an overview about the challenge, have a short look at two existing implementations and then create a first port of the fastest of those implementations to Go.\nIn this article we discover how to implement a challenges solution in Go and then increase performance by 650% going below 4 seconds from 25 seconds, which is over 20x improvement from the challenges original version of 84 seconds over the course of 9 revisions. We’ll also have a look at performance limiting aspects of this challenge.\nPerformance is our priority for now. Marks and others pointed out that code quality can be equally important. Thats very true and Niedringhaus’s first implementation was “just” about how to solve the challenge and not about performance; that became a focus when other solutions where available to her. For a program to run such a long time, nearly one an a half minute, it is a valid thing to measure its performance and then compare it to the code that lead to this perfomance. With that measurement we can at least quantify a quality of the code.\nBut lets first get an overview about the challenge, have a short look at two existing implementations and then create a first port of the fastest of those implementations to Go.\nIn this article we discover how to implement a challenges solution in Go and then increase performance by 650% going below 4 seconds from 25 seconds, which is over 20x improvement from the challenges original version of 84 seconds over the course of 9 revisions. We’ll also have a look at performance limiting aspects of this challenge.\nPerformance is our priority for now. Marks and others pointed out that code quality can be equally important. Thats very true and Niedringhaus’s first implementation was “just” about how to solve the challenge and not about performance; that became a focus when other solutions where available to her. For a program to run such a long time, nearly one an a half minute, it is a valid thing to measure its performance and then compare it to the code that lead to this perfomance. With that measurement we can at least quantify a quality of the code.\nBut lets first get an overview about the challenge, have a short look at two existing implementations and then create a first port of the fastest of those implementations to Go.\nIn this article we discover how to implement a challenges solution in Go and then increase performance by 650% going below 4 seconds from 25 seconds, which is over 20x improvement from the challenges original version of 84 seconds over the course of 9 revisions. We’ll also have a look at performance limiting aspects of this challenge.\nPerformance is our priority for now. Marks and others pointed out that code quality can be equally important. Thats very true and Niedringhaus’s first implementation was “just” about how to solve the challenge and not about performance; that became a focus when other solutions where available to her. For a program to run such a long time, nearly one an a half minute, it is a valid thing to measure its performance and then compare it to the code that lead to this perfomance. With that measurement we can at least quantify a quality of the code.\nBut lets first get an overview about the challenge, have a short look at two existing implementations and then create a first port of the fastest of those implementations to Go.\nIn this article we discover how to implement a challenges solution in Go and then increase performance by 650% going below 4 seconds from 25 seconds, which is over 20x improvement from the challenges original version of 84 seconds over the course of 9 revisions. We’ll also have a look at performance limiting aspects of this challenge.\nPerformance is our priority for now. Marks and others pointed out that code quality can be equally important. Thats very true and Niedringhaus’s first implementation was “just” about how to solve the challenge and not about performance; that became a focus when other solutions where available to her. For a program to run such a long time, nearly one an a half minute, it is a valid thing to measure its performance and then compare it to the code that lead to this perfomance. With that measurement we can at least quantify a quality of the code.\nBut lets first get an overview about the challenge, have a short look at two existing implementations and then create a first port of the fastest of those implementations to Go.\nIn this article we discover how to implement a challenges solution in Go and then increase performance by 650% going below 4 seconds from 25 seconds, which is over 20x improvement from the challenges original version of 84 seconds over the course of 9 revisions. We’ll also have a look at performance limiting aspects of this challenge.\nPerformance is our priority for now. Marks and others pointed out that code quality can be equally important. Thats very true and Niedringhaus’s first implementation was “just” about how to solve the challenge and not about performance; that became a focus when other solutions where available to her. For a program to run such a long time, nearly one an a half minute, it is a valid thing to measure its performance and then compare it to the code that lead to this perfomance. With that measurement we can at least quantify a quality of the code.\nBut lets first get an overview about the challenge, have a short look at two existing implementations and then create a first port of the fastest of those implementations to Go.\nIn this article we discover how to implement a challenges solution in Go and then increase performance by 650% going below 4 seconds from 25 seconds, which is over 20x improvement from the challenges original version of 84 seconds over the course of 9 revisions. We’ll also have a look at performance limiting aspects of this challenge.\nPerformance is our priority for now. Marks and others pointed out that code quality can be equally important. Thats very true and Niedringhaus’s first implementation was “just” about how to solve the challenge and not about performance; that became a focus when other solutions where available to her. For a program to run such a long time, nearly one an a half minute, it is a valid thing to measure its performance and then compare it to the code that lead to this perfomance. With that measurement we can at least quantify a quality of the code.\nBut lets first get an overview about the challenge, have a short look at two existing implementations and then create a first port of the fastest of those implementations to Go.\nIn this article we discover how to implement a challenges solution in Go and then increase performance by 650% going below 4 seconds from 25 seconds, which is over 20x improvement from the challenges original version of 84 seconds over the course of 9 revisions. We’ll also have a look at performance limiting aspects of this challenge.\nPerformance is our priority for now. Marks and others pointed out that code quality can be equally important. Thats very true and Niedringhaus’s first implementation was “just” about how to solve the challenge and not about performance; that became a focus when other solutions where available to her. For a program to run such a long time, nearly one an a half minute, it is a valid thing to measure its performance and then compare it to the code that lead to this perfomance. With that measurement we can at least quantify a quality of the code.\nBut lets first get an overview about the challenge, have a short look at two existing implementations and then create a first port of the fastest of those implementations to Go."
var letters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
var digits = "0123456789"

func BenchmarkQuickString(b *testing.B) {
	for i := 0; i < b.N; i++ {
		QuickReplace(text, letters, "x")
	}
}

func BenchmarkQuickDigits(b *testing.B) {
	for i := 0; i < b.N; i++ {
		QuickReplace(text, digits, "0")
	}
}